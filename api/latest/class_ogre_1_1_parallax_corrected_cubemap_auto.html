<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE-Next: Ogre::ParallaxCorrectedCubemapAuto Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE-Next<span id="projectnumber">&#160;latest</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_parallax_corrected_cubemap_auto.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ogre_1_1_parallax_corrected_cubemap_auto-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::ParallaxCorrectedCubemapAuto Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Per-Pixel reflection probes.  
 <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#details">More...</a></p>

<p><code>#include &lt;OgreParallaxCorrectedCubemapAuto.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::ParallaxCorrectedCubemapAuto:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_parallax_corrected_cubemap_auto__inherit__graph.svg" width="496" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a947106ab4b5ba03957782d7298588334"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a947106ab4b5ba03957782d7298588334">ParallaxCorrectedCubemapAuto</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, <a class="el" href="class_ogre_1_1_root.html">Root</a> *root, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager, const <a class="el" href="class_ogre_1_1_compositor_workspace_def.html">CompositorWorkspaceDef</a> *probeWorkspaceDef)</td></tr>
<tr class="separator:a947106ab4b5ba03957782d7298588334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dab9e5cac808962dc2005c0db63cff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a65dab9e5cac808962dc2005c0db63cff">~ParallaxCorrectedCubemapAuto</a> () override</td></tr>
<tr class="separator:a65dab9e5cac808962dc2005c0db63cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6144590eb0521162ea1218bf41362898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a6144590eb0521162ea1218bf41362898">_acquireTextureSlot</a> (<a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> &amp;outTexSlot) override</td></tr>
<tr class="memdesc:a6144590eb0521162ea1218bf41362898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a texture with a given slot.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a6144590eb0521162ea1218bf41362898">More...</a><br /></td></tr>
<tr class="separator:a6144590eb0521162ea1218bf41362898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b41b5c7a9697a0cc42d9ad0eac5aeb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a27b41b5c7a9697a0cc42d9ad0eac5aeb">_addManuallyActiveProbe</a> (<a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *probe)</td></tr>
<tr class="separator:a27b41b5c7a9697a0cc42d9ad0eac5aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16814d445952031030aff054e32e0c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a16814d445952031030aff054e32e0c59">_copyRenderTargetToCubemap</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> cubemapArrayIdx) override</td></tr>
<tr class="separator:a16814d445952031030aff054e32e0c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae800532adcc236ef859a9b3dac6f9d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#aae800532adcc236ef859a9b3dac6f9d9">_notifyPreparePassHash</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;viewMatrix)</td></tr>
<tr class="separator:aae800532adcc236ef859a9b3dac6f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e192821f896ab3ee77dc684d6f1b71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a97e192821f896ab3ee77dc684d6f1b71">_releaseManualHardwareResources</a> ()</td></tr>
<tr class="separator:a97e192821f896ab3ee77dc684d6f1b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc71801990dd4c1ec879a73a5abe0a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#abc71801990dd4c1ec879a73a5abe0a80">_releaseTextureSlot</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> texSlot) override</td></tr>
<tr class="separator:abc71801990dd4c1ec879a73a5abe0a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2767b1b55dedd1b68cefabe18f5c3259"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a2767b1b55dedd1b68cefabe18f5c3259">_removeManuallyActiveProbe</a> (<a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *probe)</td></tr>
<tr class="separator:a2767b1b55dedd1b68cefabe18f5c3259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb1e5b92d6fd2e4cf212415da42b670"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#abfb1e5b92d6fd2e4cf212415da42b670">_restoreManualHardwareResources</a> ()</td></tr>
<tr class="separator:abfb1e5b92d6fd2e4cf212415da42b670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7b9f8e12e3d0a2e4fe0accda5960af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#aed7b9f8e12e3d0a2e4fe0accda5960af">_setIsRendering</a> (bool bIsRendering)</td></tr>
<tr class="separator:aed7b9f8e12e3d0a2e4fe0accda5960af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150467bdcc98979f2284947300b8af50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a150467bdcc98979f2284947300b8af50">_setProbeRenderInProgress</a> (<a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *probe)</td></tr>
<tr class="separator:a150467bdcc98979f2284947300b8af50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64a04cfd731369f573bfcd3e04dd26b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#af64a04cfd731369f573bfcd3e04dd26b">allWorkspacesBeforeBeginUpdate</a> () override</td></tr>
<tr class="memdesc:af64a04cfd731369f573bfcd3e04dd26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> (not <a class="el" href="class_ogre_1_1_compositor_workspace.html" title="A compositor workspace is the main interface to render into an RT, be it a RenderWindow or an RTT (Re...">CompositorWorkspace</a>) when we're about to begin updating all the workspaces.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#af64a04cfd731369f573bfcd3e04dd26b">More...</a><br /></td></tr>
<tr class="separator:af64a04cfd731369f573bfcd3e04dd26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4a9d18d3a13eb4f00838dbcd913a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a6c4a9d18d3a13eb4f00838dbcd913a90">allWorkspacesBeginUpdate</a> () override</td></tr>
<tr class="memdesc:a6c4a9d18d3a13eb4f00838dbcd913a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> (not <a class="el" href="class_ogre_1_1_compositor_workspace.html" title="A compositor workspace is the main interface to render into an RT, be it a RenderWindow or an RTT (Re...">CompositorWorkspace</a>) when we're about to update all the workspaces (it's safe to update your own workspaces without calling _beginUpdate and _endUpdate) Warning: Don't add/remove listeners to <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> inside this function.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a6c4a9d18d3a13eb4f00838dbcd913a90">More...</a><br /></td></tr>
<tr class="separator:a6c4a9d18d3a13eb4f00838dbcd913a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcacb18bd56faa1d1a34eda795d54687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#adcacb18bd56faa1d1a34eda795d54687">createProbe</a> ()</td></tr>
<tr class="memdesc:adcacb18bd56faa1d1a34eda795d54687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cubemap probe.  <a href="class_ogre_1_1_parallax_corrected_cubemap_base.html#adcacb18bd56faa1d1a34eda795d54687">More...</a><br /></td></tr>
<tr class="separator:adcacb18bd56faa1d1a34eda795d54687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc6aea47316adfb9eacfd49fc3ff284"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#addc6aea47316adfb9eacfd49fc3ff284">destroyAllProbes</a> ()</td></tr>
<tr class="separator:addc6aea47316adfb9eacfd49fc3ff284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9439802aaa42a3d515e9d0abcf06732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#ab9439802aaa42a3d515e9d0abcf06732">destroyProbe</a> (<a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *probe) override</td></tr>
<tr class="separator:ab9439802aaa42a3d515e9d0abcf06732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94ca0fd077c8bcbc316e27a1a2d56a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a8e94ca0fd077c8bcbc316e27a1a2d56a">eventOccurred</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;eventName, const <a class="el" href="group___general.html#ga442a408f658c0cbfbe3e404e91a0fcc5">NameValuePairList</a> *parameters) override</td></tr>
<tr class="memdesc:a8e94ca0fd077c8bcbc316e27a1a2d56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rendersystem-specific event occurred.  <a href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a8e94ca0fd077c8bcbc316e27a1a2d56a">More...</a><br /></td></tr>
<tr class="separator:a8e94ca0fd077c8bcbc316e27a1a2d56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cb6ba4ad22e0d678ec2f97df5eb0e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a54cb6ba4ad22e0d678ec2f97df5eb0e6">fillConstBufferData</a> (const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;viewMatrix, float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> passBufferPtr) const</td></tr>
<tr class="separator:a54cb6ba4ad22e0d678ec2f97df5eb0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ca9b09fa2101bb26d988fa2cc94929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#ad0ca9b09fa2101bb26d988fa2cc94929">findIbl</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *baseParams) override</td></tr>
<tr class="separator:ad0ca9b09fa2101bb26d988fa2cc94929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92117214661a34289dbba2deaab5861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#ae92117214661a34289dbba2deaab5861">findTmpRtt</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *baseParams) override</td></tr>
<tr class="memdesc:ae92117214661a34289dbba2deaab5861"><td class="mdescLeft">&#160;</td><td class="mdescRight">See mTmpRtt.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#ae92117214661a34289dbba2deaab5861">More...</a><br /></td></tr>
<tr class="separator:ae92117214661a34289dbba2deaab5861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d0140678c18a013ac45aa544c00bfd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_frame_listener.html#af1d0140678c18a013ac45aa544c00bfd">frameEnded</a> (const <a class="el" href="struct_ogre_1_1_frame_event.html">FrameEvent</a> &amp;evt)</td></tr>
<tr class="memdesc:af1d0140678c18a013ac45aa544c00bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a frame has been rendered.  <a href="class_ogre_1_1_frame_listener.html#af1d0140678c18a013ac45aa544c00bfd">More...</a><br /></td></tr>
<tr class="separator:af1d0140678c18a013ac45aa544c00bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2785cb38589ab9df123fa401cbda31c3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_frame_listener.html#a2785cb38589ab9df123fa401cbda31c3">frameRenderingQueued</a> (const <a class="el" href="struct_ogre_1_1_frame_event.html">FrameEvent</a> &amp;evt)</td></tr>
<tr class="memdesc:a2785cb38589ab9df123fa401cbda31c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after all render targets have had their rendering commands issued, but before render windows have been asked to flip their buffers over.  <a href="class_ogre_1_1_frame_listener.html#a2785cb38589ab9df123fa401cbda31c3">More...</a><br /></td></tr>
<tr class="separator:a2785cb38589ab9df123fa401cbda31c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd9095b56846533c1d4d9cd7b91f13f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a2fd9095b56846533c1d4d9cd7b91f13f">frameStarted</a> (const <a class="el" href="struct_ogre_1_1_frame_event.html">FrameEvent</a> &amp;evt) override</td></tr>
<tr class="memdesc:a2fd9095b56846533c1d4d9cd7b91f13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a frame is about to begin rendering.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a2fd9095b56846533c1d4d9cd7b91f13f">More...</a><br /></td></tr>
<tr class="separator:a2fd9095b56846533c1d4d9cd7b91f13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0077aedaca1f07471286c601e56ec9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ad0077aedaca1f07471286c601e56ec9e">getAutomaticMode</a> () const</td></tr>
<tr class="separator:ad0077aedaca1f07471286c601e56ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26e088032f5d07cad201877a5dee111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ae26e088032f5d07cad201877a5dee111">getBindTexture</a> () const</td></tr>
<tr class="separator:ae26e088032f5d07cad201877a5dee111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee956ec591edacf6553ec59a556891c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a4ee956ec591edacf6553ec59a556891c">getBindTrilinearSamplerblock</a> ()</td></tr>
<tr class="separator:a4ee956ec591edacf6553ec59a556891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30535a340355abc1ec25a49b8052475"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ad30535a340355abc1ec25a49b8052475">getConstBufferSize</a> ()</td></tr>
<tr class="separator:ad30535a340355abc1ec25a49b8052475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7caf596cfa8b07fda46850ecb5298f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_workspace_def.html">CompositorWorkspaceDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#aa7caf596cfa8b07fda46850ecb5298f1">getDefaultWorkspaceDef</a> () const</td></tr>
<tr class="separator:aa7caf596cfa8b07fda46850ecb5298f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4e16607c05c86fd1d333b155ae258e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a4f4e16607c05c86fd1d333b155ae258e">getEnabled</a> () const</td></tr>
<tr class="separator:a4f4e16607c05c86fd1d333b155ae258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01918a318e68381ac48bfc642b6e5ac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a01918a318e68381ac48bfc642b6e5ac2">getIblTargetTextureFlags</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat) const</td></tr>
<tr class="separator:a01918a318e68381ac48bfc642b6e5ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152c8f646a835c2f88585ad4fe0413a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">getId</a> () const</td></tr>
<tr class="memdesc:ab152c8f646a835c2f88585ad4fe0413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of this object.  <a href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">More...</a><br /></td></tr>
<tr class="separator:ab152c8f646a835c2f88585ad4fe0413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac709b3858a764dabc0790cee12afa097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">ParallaxCorrectedCubemapAutoListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#ac709b3858a764dabc0790cee12afa097">getListener</a> () const</td></tr>
<tr class="separator:ac709b3858a764dabc0790cee12afa097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c136a41db7e8826ae797cdcd07e8b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a2f4d75e871cfa4db95557dbb4fad0980">CubemapProbeVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a68c136a41db7e8826ae797cdcd07e8b7">getProbes</a> () const</td></tr>
<tr class="separator:a68c136a41db7e8826ae797cdcd07e8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b31360a12a5f696a1d68bdacff4362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ab6b31360a12a5f696a1d68bdacff4362">getSceneManager</a> () const</td></tr>
<tr class="separator:ab6b31360a12a5f696a1d68bdacff4362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e312bf2761f25b3062cc475f1dd5df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a55e312bf2761f25b3062cc475f1dd5df">getUseDpm2DArray</a> () const</td></tr>
<tr class="separator:a55e312bf2761f25b3062cc475f1dd5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c02d43a1c4d604c7ee91c512c875e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a1c02d43a1c4d604c7ee91c512c875e2a">isRendering</a> () const</td></tr>
<tr class="memdesc:a1c02d43a1c4d604c7ee91c512c875e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform whether we're currently updating a probe.  <a href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a1c02d43a1c4d604c7ee91c512c875e2a">More...</a><br /></td></tr>
<tr class="separator:a1c02d43a1c4d604c7ee91c512c875e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0523432c6e5133ff4fc251111a60e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a57e0523432c6e5133ff4fc251111a60e">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;right)</td></tr>
<tr class="separator:a57e0523432c6e5133ff4fc251111a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a0ae22596b5bd2a3faf2958ab3d109d1f">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *right)</td></tr>
<tr class="separator:a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eba922fa823c5142a3078de97cf4cc0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#a9eba922fa823c5142a3078de97cf4cc0">passEarlyPreExecute</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass)</td></tr>
<tr class="memdesc:a9eba922fa823c5142a3078de97cf4cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called early on in pass' execution.  <a href="class_ogre_1_1_compositor_workspace_listener.html#a9eba922fa823c5142a3078de97cf4cc0">More...</a><br /></td></tr>
<tr class="separator:a9eba922fa823c5142a3078de97cf4cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb1faa16a3a3f920edf5d356160ed3e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#aafb1faa16a3a3f920edf5d356160ed3e">passPosExecute</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass)</td></tr>
<tr class="memdesc:aafb1faa16a3a3f920edf5d356160ed3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a pass has been executed.  <a href="class_ogre_1_1_compositor_workspace_listener.html#aafb1faa16a3a3f920edf5d356160ed3e">More...</a><br /></td></tr>
<tr class="separator:aafb1faa16a3a3f920edf5d356160ed3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f41e739f1d88f880e7ff6fbce03073a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a8f41e739f1d88f880e7ff6fbce03073a">passPreExecute</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass) override</td></tr>
<tr class="memdesc:a8f41e739f1d88f880e7ff6fbce03073a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when each pass is about to be executed.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a8f41e739f1d88f880e7ff6fbce03073a">More...</a><br /></td></tr>
<tr class="separator:a8f41e739f1d88f880e7ff6fbce03073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48c3669cc7eea1407af04641a48b955"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#aa48c3669cc7eea1407af04641a48b955">passSceneAfterFrustumCulling</a> (<a class="el" href="class_ogre_1_1_compositor_pass_scene.html">CompositorPassScene</a> *pass)</td></tr>
<tr class="memdesc:aa48c3669cc7eea1407af04641a48b955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a pass scene has performed frustum caulling but has yet to prepare and execute rendering commands.  <a href="class_ogre_1_1_compositor_workspace_listener.html#aa48c3669cc7eea1407af04641a48b955">More...</a><br /></td></tr>
<tr class="separator:aa48c3669cc7eea1407af04641a48b955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c7e6c919c3bf55475a0a04160189fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#a75c7e6c919c3bf55475a0a04160189fc">passSceneAfterShadowMaps</a> (<a class="el" href="class_ogre_1_1_compositor_pass_scene.html">CompositorPassScene</a> *pass)</td></tr>
<tr class="memdesc:a75c7e6c919c3bf55475a0a04160189fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a pass scene has rendered shadow casting (it gets called even if there is no shadow node).  <a href="class_ogre_1_1_compositor_workspace_listener.html#a75c7e6c919c3bf55475a0a04160189fc">More...</a><br /></td></tr>
<tr class="separator:a75c7e6c919c3bf55475a0a04160189fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13b25da99dc231bd118cc45353d7a6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ac13b25da99dc231bd118cc45353d7a6c">prepareForClearScene</a> ()</td></tr>
<tr class="memdesc:ac13b25da99dc231bd118cc45353d7a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the Proxy Items.  <a href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ac13b25da99dc231bd118cc45353d7a6c">More...</a><br /></td></tr>
<tr class="separator:ac13b25da99dc231bd118cc45353d7a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c8908f3b3eacd7e688392ff1c691c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#aed2c8908f3b3eacd7e688392ff1c691c">releaseIbl</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *tmpRtt) override</td></tr>
<tr class="separator:aed2c8908f3b3eacd7e688392ff1c691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932214b69592fe3313cb4d179d01de3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a932214b69592fe3313cb4d179d01de3a">releaseTmpRtt</a> (const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *tmpRtt) override</td></tr>
<tr class="separator:a932214b69592fe3313cb4d179d01de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee0f24e40d71aedd68a96f63c5edb17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#adee0f24e40d71aedd68a96f63c5edb17">restoreFromClearScene</a> ()</td></tr>
<tr class="separator:adee0f24e40d71aedd68a96f63c5edb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e40f6c89fcfdfee2057ca6efe622299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a0e40f6c89fcfdfee2057ca6efe622299">setEnabled</a> (bool bEnabled, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> maxNumProbes, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:a0e40f6c89fcfdfee2057ca6efe622299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables this <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html" title="Per-Pixel reflection probes.">ParallaxCorrectedCubemapAuto</a> system.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a0e40f6c89fcfdfee2057ca6efe622299">More...</a><br /></td></tr>
<tr class="separator:a0e40f6c89fcfdfee2057ca6efe622299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa948bcd4631267cd46bc10e0a85bd225"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#aa948bcd4631267cd46bc10e0a85bd225">setListener</a> (<a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">ParallaxCorrectedCubemapAutoListener</a> *listener)</td></tr>
<tr class="separator:aa948bcd4631267cd46bc10e0a85bd225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66abd5518918092b8d4ee072dfa172bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a66abd5518918092b8d4ee072dfa172bf">setUpdatedTrackedDataFromCamera</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *trackedCamera)</td></tr>
<tr class="memdesc:a66abd5518918092b8d4ee072dfa172bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will update both mTrackedPosition with appropiate settings every time it's called.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a66abd5518918092b8d4ee072dfa172bf">More...</a><br /></td></tr>
<tr class="separator:a66abd5518918092b8d4ee072dfa172bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e542a62cb671f6f0a394bcb1130c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a42e542a62cb671f6f0a394bcb1130c71">setUseDpm2DArray</a> (bool useDpm2DArray)</td></tr>
<tr class="memdesc:a42e542a62cb671f6f0a394bcb1130c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we should use Dual Paraboloid Mapping with 2D Array instead of Cubemap Arrays.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a42e542a62cb671f6f0a394bcb1130c71">More...</a><br /></td></tr>
<tr class="separator:a42e542a62cb671f6f0a394bcb1130c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabb26cc06821e04f6ce6e3853755d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#afdabb26cc06821e04f6ce6e3853755d0">updateAllDirtyProbes</a> () override</td></tr>
<tr class="memdesc:afdabb26cc06821e04f6ce6e3853755d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default the probes will be constructed when the user enters the vecinity of non-static probes, and whenever a static probe is dirty.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#afdabb26cc06821e04f6ce6e3853755d0">More...</a><br /></td></tr>
<tr class="separator:afdabb26cc06821e04f6ce6e3853755d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ee72b0064a1c20c05b37995e5e139e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#a71ee72b0064a1c20c05b37995e5e139e">workspacePosUpdate</a> (<a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace)</td></tr>
<tr class="memdesc:a71ee72b0064a1c20c05b37995e5e139e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after all nodes has been updated.  <a href="class_ogre_1_1_compositor_workspace_listener.html#a71ee72b0064a1c20c05b37995e5e139e">More...</a><br /></td></tr>
<tr class="separator:a71ee72b0064a1c20c05b37995e5e139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6aea0f666028295c3efa9dc41eaceb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#aad6aea0f666028295c3efa9dc41eaceb">workspacePreUpdate</a> (<a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace)</td></tr>
<tr class="memdesc:aad6aea0f666028295c3efa9dc41eaceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before all nodes are going to be updated.  <a href="class_ogre_1_1_compositor_workspace_listener.html#aad6aea0f666028295c3efa9dc41eaceb">More...</a><br /></td></tr>
<tr class="separator:aad6aea0f666028295c3efa9dc41eaceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a910d9331477442fc2b206b65e873366b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a910d9331477442fc2b206b65e873366b">fillConstBufferData</a> (const <a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> &amp;probe, const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;viewMatrix, const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;invViewMat3, float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a> passBufferPtr)</td></tr>
<tr class="separator:a910d9331477442fc2b206b65e873366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b76be9beb79a4214a319c712b7a955c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a5b76be9beb79a4214a319c712b7a955c">getIblNumMipmaps</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height)</td></tr>
<tr class="separator:a5b76be9beb79a4214a319c712b7a955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a12c0ea75c3a53a92c55be4075e3f9184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a12c0ea75c3a53a92c55be4075e3f9184">mMask</a></td></tr>
<tr class="separator:a12c0ea75c3a53a92c55be4075e3f9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b689fd9da3fdde16a34d403dc448576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a3b689fd9da3fdde16a34d403dc448576">mPaused</a></td></tr>
<tr class="separator:a3b689fd9da3fdde16a34d403dc448576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0f0ec0f33e0bda5ddf4b16e5265ebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#aca0f0ec0f33e0bda5ddf4b16e5265ebf">mTrackedPosition</a></td></tr>
<tr class="memdesc:aca0f0ec0f33e0bda5ddf4b16e5265ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable should be updated every frame and often represents the camera position, but it can also be used set to other things like the player's character position.  <a href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#aca0f0ec0f33e0bda5ddf4b16e5265ebf">More...</a><br /></td></tr>
<tr class="separator:aca0f0ec0f33e0bda5ddf4b16e5265ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Per-Pixel reflection probes. </p>
<p >Per-Pixel reflection probes are much easier to handle, they're more flexible and powerful. However they require a modern GPU with Cubemap Arrays. Forward Clustered also must be active.</p>
<p ><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html" title="Per-Pixel reflection probes.">ParallaxCorrectedCubemapAuto</a> supports having more CubemapProbes than the maximum number of probes you pass to <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html#a0e40f6c89fcfdfee2057ca6efe622299" title="Enables/disables this ParallaxCorrectedCubemapAuto system.">ParallaxCorrectedCubemapAuto::setEnabled</a>. However only 'maxNumProbes' probes can be active at the same time. This is all done thanks to _acquireTextureSlot &amp; _releaseTextureSlot.</p>
<p >To activate a probe, call <a class="el" href="class_ogre_1_1_cubemap_probe.html#aa8ffb1d3c73359ccb630ce3699532a08" title="Initializes the workspace so we can actually render to the cubemap.">CubemapProbe::initWorkspace</a>. To deactivate it, call <a class="el" href="class_ogre_1_1_cubemap_probe.html#a039cd2098437f62fb5278a577aec1b25">CubemapProbe::destroyWorkspace</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a947106ab4b5ba03957782d7298588334" name="a947106ab4b5ba03957782d7298588334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947106ab4b5ba03957782d7298588334">&#9670;&nbsp;</a></span>ParallaxCorrectedCubemapAuto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ParallaxCorrectedCubemapAuto::ParallaxCorrectedCubemapAuto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_root.html">Root</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_workspace_def.html">CompositorWorkspaceDef</a> *&#160;</td>
          <td class="paramname"><em>probeWorkspaceDef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65dab9e5cac808962dc2005c0db63cff" name="a65dab9e5cac808962dc2005c0db63cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dab9e5cac808962dc2005c0db63cff">&#9670;&nbsp;</a></span>~ParallaxCorrectedCubemapAuto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ParallaxCorrectedCubemapAuto::~ParallaxCorrectedCubemapAuto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6144590eb0521162ea1218bf41362898" name="a6144590eb0521162ea1218bf41362898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6144590eb0521162ea1218bf41362898">&#9670;&nbsp;</a></span>_acquireTextureSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::ParallaxCorrectedCubemapAuto::_acquireTextureSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a64f3c3e34647277a00b67ae0dfa1a528">uint16</a> &amp;&#160;</td>
          <td class="paramname"><em>outTexSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires a texture with a given slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outTexSlot</td><td>[out] Texture slot. Value is left untouched if return value is nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Texture. Can be nullptr if ran out of slots. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a32d26cbe33ecde8af0fc42797941d14f">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="a27b41b5c7a9697a0cc42d9ad0eac5aeb" name="a27b41b5c7a9697a0cc42d9ad0eac5aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b41b5c7a9697a0cc42d9ad0eac5aeb">&#9670;&nbsp;</a></span>_addManuallyActiveProbe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::_addManuallyActiveProbe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *&#160;</td>
          <td class="paramname"><em>probe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#ae00f0995b5a8e65e05c4440daeddc69d">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="a16814d445952031030aff054e32e0c59" name="a16814d445952031030aff054e32e0c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16814d445952031030aff054e32e0c59">&#9670;&nbsp;</a></span>_copyRenderTargetToCubemap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::_copyRenderTargetToCubemap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>cubemapArrayIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#af14385c6c69f71cfb54a0cd3a2243f4d">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="aae800532adcc236ef859a9b3dac6f9d9" name="aae800532adcc236ef859a9b3dac6f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae800532adcc236ef859a9b3dac6f9d9">&#9670;&nbsp;</a></span>_notifyPreparePassHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::_notifyPreparePassHash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>viewMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#acd55a37dac452846f9e82e4d6b015a96">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="a97e192821f896ab3ee77dc684d6f1b71" name="a97e192821f896ab3ee77dc684d6f1b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e192821f896ab3ee77dc684d6f1b71">&#9670;&nbsp;</a></span>_releaseManualHardwareResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::_releaseManualHardwareResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#a7cae6aadf4c75b120fd218ecc0d6979c">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="abc71801990dd4c1ec879a73a5abe0a80" name="abc71801990dd4c1ec879a73a5abe0a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc71801990dd4c1ec879a73a5abe0a80">&#9670;&nbsp;</a></span>_releaseTextureSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::_releaseTextureSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ad06ae285e469e60ad4be65a4b2903894">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="a2767b1b55dedd1b68cefabe18f5c3259" name="a2767b1b55dedd1b68cefabe18f5c3259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2767b1b55dedd1b68cefabe18f5c3259">&#9670;&nbsp;</a></span>_removeManuallyActiveProbe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::_removeManuallyActiveProbe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *&#160;</td>
          <td class="paramname"><em>probe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#a726c0fe718ed2e83ffcf683389efbd45">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="abfb1e5b92d6fd2e4cf212415da42b670" name="abfb1e5b92d6fd2e4cf212415da42b670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb1e5b92d6fd2e4cf212415da42b670">&#9670;&nbsp;</a></span>_restoreManualHardwareResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::_restoreManualHardwareResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#a565c77a96f073eeddd6e57a636d706d6">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="aed7b9f8e12e3d0a2e4fe0accda5960af" name="aed7b9f8e12e3d0a2e4fe0accda5960af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7b9f8e12e3d0a2e4fe0accda5960af">&#9670;&nbsp;</a></span>_setIsRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapBase::_setIsRendering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsRendering</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a150467bdcc98979f2284947300b8af50" name="a150467bdcc98979f2284947300b8af50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150467bdcc98979f2284947300b8af50">&#9670;&nbsp;</a></span>_setProbeRenderInProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapBase::_setProbeRenderInProgress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *&#160;</td>
          <td class="paramname"><em>probe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af64a04cfd731369f573bfcd3e04dd26b" name="af64a04cfd731369f573bfcd3e04dd26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64a04cfd731369f573bfcd3e04dd26b">&#9670;&nbsp;</a></span>allWorkspacesBeforeBeginUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::allWorkspacesBeforeBeginUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> (not <a class="el" href="class_ogre_1_1_compositor_workspace.html" title="A compositor workspace is the main interface to render into an RT, be it a RenderWindow or an RTT (Re...">CompositorWorkspace</a>) when we're about to begin updating all the workspaces. </p>
<p >You'll have to manage the <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API.">RenderSystem</a> and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to call the adequate begin/end calls Warning: Don't add/remove listeners to <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> inside this function. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#a59e12b82c695a8073cf59b2f36e91a7b">Ogre::CompositorWorkspaceListener</a>.</p>

</div>
</div>
<a id="a6c4a9d18d3a13eb4f00838dbcd913a90" name="a6c4a9d18d3a13eb4f00838dbcd913a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4a9d18d3a13eb4f00838dbcd913a90">&#9670;&nbsp;</a></span>allWorkspacesBeginUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::allWorkspacesBeginUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> (not <a class="el" href="class_ogre_1_1_compositor_workspace.html" title="A compositor workspace is the main interface to render into an RT, be it a RenderWindow or an RTT (Re...">CompositorWorkspace</a>) when we're about to update all the workspaces (it's safe to update your own workspaces without calling _beginUpdate and _endUpdate) Warning: Don't add/remove listeners to <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> inside this function. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#a47d89a97c8d3e1726c9a8ca2f334c23c">Ogre::CompositorWorkspaceListener</a>.</p>

</div>
</div>
<a id="adcacb18bd56faa1d1a34eda795d54687" name="adcacb18bd56faa1d1a34eda795d54687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcacb18bd56faa1d1a34eda795d54687">&#9670;&nbsp;</a></span>createProbe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> * Ogre::ParallaxCorrectedCubemapBase::createProbe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cubemap probe. </p>

</div>
</div>
<a id="addc6aea47316adfb9eacfd49fc3ff284" name="addc6aea47316adfb9eacfd49fc3ff284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc6aea47316adfb9eacfd49fc3ff284">&#9670;&nbsp;</a></span>destroyAllProbes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::destroyAllProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#a038c44238d84b432b2bde86e8dcf3bba">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="ab9439802aaa42a3d515e9d0abcf06732" name="ab9439802aaa42a3d515e9d0abcf06732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9439802aaa42a3d515e9d0abcf06732">&#9670;&nbsp;</a></span>destroyProbe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::destroyProbe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> *&#160;</td>
          <td class="paramname"><em>probe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a69ecd483452d8edd6cc5b61cbd483dca">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="a8e94ca0fd077c8bcbc316e27a1a2d56a" name="a8e94ca0fd077c8bcbc316e27a1a2d56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e94ca0fd077c8bcbc316e27a1a2d56a">&#9670;&nbsp;</a></span>eventOccurred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapBase::eventOccurred </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___general.html#ga442a408f658c0cbfbe3e404e91a0fcc5">NameValuePairList</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A rendersystem-specific event occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event which has occurred </td></tr>
    <tr><td class="paramname">parameters</td><td>A list of parameters that may belong to this event, may be null if there are no parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_render_system_1_1_listener.html#aafc262fea83eae3a360aeb16d1cc7ef9">Ogre::RenderSystem::Listener</a>.</p>

</div>
</div>
<a id="a910d9331477442fc2b206b65e873366b" name="a910d9331477442fc2b206b65e873366b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910d9331477442fc2b206b65e873366b">&#9670;&nbsp;</a></span>fillConstBufferData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::ParallaxCorrectedCubemapBase::fillConstBufferData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_cubemap_probe.html">CubemapProbe</a> &amp;&#160;</td>
          <td class="paramname"><em>probe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>viewMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix3.html">Matrix3</a> &amp;&#160;</td>
          <td class="paramname"><em>invViewMat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>passBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54cb6ba4ad22e0d678ec2f97df5eb0e6" name="a54cb6ba4ad22e0d678ec2f97df5eb0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cb6ba4ad22e0d678ec2f97df5eb0e6">&#9670;&nbsp;</a></span>fillConstBufferData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::fillConstBufferData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>viewMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *<a class="el" href="_ogre_platform_8h.html#a6decd303d90f9cd75d6bb79d51ea2154">RESTRICT_ALIAS</a>&#160;</td>
          <td class="paramname"><em>passBufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#acebeac36bacd831a499598893346b0f0">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="ad0ca9b09fa2101bb26d988fa2cc94929" name="ad0ca9b09fa2101bb26d988fa2cc94929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ca9b09fa2101bb26d988fa2cc94929">&#9670;&nbsp;</a></span>findIbl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::ParallaxCorrectedCubemapAuto::findIbl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>baseParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ab9ecd14e1039e6b233520a301bab9c54">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="ae92117214661a34289dbba2deaab5861" name="ae92117214661a34289dbba2deaab5861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92117214661a34289dbba2deaab5861">&#9670;&nbsp;</a></span>findTmpRtt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::ParallaxCorrectedCubemapAuto::findTmpRtt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>baseParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See mTmpRtt. </p>
<p >Finds an RTT that is compatible to copy to baseParams. Creates one if none found. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a8c7776c5b5e9f2123a66a12ff8f423be">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="af1d0140678c18a013ac45aa544c00bfd" name="af1d0140678c18a013ac45aa544c00bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d0140678c18a013ac45aa544c00bfd">&#9670;&nbsp;</a></span>frameEnded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::FrameListener::frameEnded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_frame_event.html">FrameEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a frame has been rendered. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This event happens after all render targets have been fully updated and the buffers switched. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True to continue with the next frame, false to drop out of the rendering loop. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_frame_time_controller_value.html#a7cf58ff02b01a353e19f9d8fb5d89991">Ogre::FrameTimeControllerValue</a>.</p>

</div>
</div>
<a id="a2785cb38589ab9df123fa401cbda31c3" name="a2785cb38589ab9df123fa401cbda31c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2785cb38589ab9df123fa401cbda31c3">&#9670;&nbsp;</a></span>frameRenderingQueued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::FrameListener::frameRenderingQueued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_frame_event.html">FrameEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after all render targets have had their rendering commands issued, but before render windows have been asked to flip their buffers over. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The usefulness of this event comes from the fact that rendering commands are queued for the GPU to process. These can take a little while to finish, and so while that is happening the CPU can be doing useful things. Once the request to 'flip buffers' happens, the thread requesting it will block until the GPU is ready, which can waste CPU cycles. Therefore, it is often a good idea to use this callback to perform per-frame processing. Of course because the frame's rendering commands have already been issued, any changes you make will only take effect from the next frame, but in most cases that's not noticeable. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True to continue rendering, false to drop out of the rendering loop. </dd></dl>

</div>
</div>
<a id="a2fd9095b56846533c1d4d9cd7b91f13f" name="a2fd9095b56846533c1d4d9cd7b91f13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd9095b56846533c1d4d9cd7b91f13f">&#9670;&nbsp;</a></span>frameStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ParallaxCorrectedCubemapAuto::frameStarted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_frame_event.html">FrameEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a frame is about to begin rendering. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This event happens before any render targets have begun updating. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True to go ahead, false to abort rendering and drop out of the rendering loop. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_frame_listener.html#a88238b65f9ce32f0de8c5eeeb7b6c6ad">Ogre::FrameListener</a>.</p>

</div>
</div>
<a id="ad0077aedaca1f07471286c601e56ec9e" name="ad0077aedaca1f07471286c601e56ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0077aedaca1f07471286c601e56ec9e">&#9670;&nbsp;</a></span>getAutomaticMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ParallaxCorrectedCubemapBase::getAutomaticMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae26e088032f5d07cad201877a5dee111" name="ae26e088032f5d07cad201877a5dee111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26e088032f5d07cad201877a5dee111">&#9670;&nbsp;</a></span>getBindTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::ParallaxCorrectedCubemapBase::getBindTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ee956ec591edacf6553ec59a556891c" name="a4ee956ec591edacf6553ec59a556891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee956ec591edacf6553ec59a556891c">&#9670;&nbsp;</a></span>getBindTrilinearSamplerblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> * Ogre::ParallaxCorrectedCubemapBase::getBindTrilinearSamplerblock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad30535a340355abc1ec25a49b8052475" name="ad30535a340355abc1ec25a49b8052475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30535a340355abc1ec25a49b8052475">&#9670;&nbsp;</a></span>getConstBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::ParallaxCorrectedCubemapBase::getConstBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#a8025ce6235307ce1c741698ecc64fa9a">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="aa7caf596cfa8b07fda46850ecb5298f1" name="aa7caf596cfa8b07fda46850ecb5298f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7caf596cfa8b07fda46850ecb5298f1">&#9670;&nbsp;</a></span>getDefaultWorkspaceDef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_workspace_def.html">CompositorWorkspaceDef</a> * Ogre::ParallaxCorrectedCubemapBase::getDefaultWorkspaceDef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f4e16607c05c86fd1d333b155ae258e" name="a4f4e16607c05c86fd1d333b155ae258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4e16607c05c86fd1d333b155ae258e">&#9670;&nbsp;</a></span>getEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ParallaxCorrectedCubemapAuto::getEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b76be9beb79a4214a319c712b7a955c" name="a5b76be9beb79a4214a319c712b7a955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b76be9beb79a4214a319c712b7a955c">&#9670;&nbsp;</a></span>getIblNumMipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::ParallaxCorrectedCubemapBase::getIblNumMipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01918a318e68381ac48bfc642b6e5ac2" name="a01918a318e68381ac48bfc642b6e5ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01918a318e68381ac48bfc642b6e5ac2">&#9670;&nbsp;</a></span>getIblTargetTextureFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::ParallaxCorrectedCubemapBase::getIblTargetTextureFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab152c8f646a835c2f88585ad4fe0413a" name="ab152c8f646a835c2f88585ad4fe0413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab152c8f646a835c2f88585ad4fe0413a">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> Ogre::IdObject::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique id of this object. </p>

</div>
</div>
<a id="ac709b3858a764dabc0790cee12afa097" name="ac709b3858a764dabc0790cee12afa097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac709b3858a764dabc0790cee12afa097">&#9670;&nbsp;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">ParallaxCorrectedCubemapAutoListener</a> * Ogre::ParallaxCorrectedCubemapAuto::getListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68c136a41db7e8826ae797cdcd07e8b7" name="a68c136a41db7e8826ae797cdcd07e8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c136a41db7e8826ae797cdcd07e8b7">&#9670;&nbsp;</a></span>getProbes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a2f4d75e871cfa4db95557dbb4fad0980">CubemapProbeVec</a> &amp; Ogre::ParallaxCorrectedCubemapBase::getProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6b31360a12a5f696a1d68bdacff4362" name="ab6b31360a12a5f696a1d68bdacff4362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b31360a12a5f696a1d68bdacff4362">&#9670;&nbsp;</a></span>getSceneManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> * Ogre::ParallaxCorrectedCubemapBase::getSceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55e312bf2761f25b3062cc475f1dd5df" name="a55e312bf2761f25b3062cc475f1dd5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e312bf2761f25b3062cc475f1dd5df">&#9670;&nbsp;</a></span>getUseDpm2DArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ParallaxCorrectedCubemapBase::getUseDpm2DArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c02d43a1c4d604c7ee91c512c875e2a" name="a1c02d43a1c4d604c7ee91c512c875e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c02d43a1c4d604c7ee91c512c875e2a">&#9670;&nbsp;</a></span>isRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ParallaxCorrectedCubemapBase::isRendering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inform whether we're currently updating a probe. </p>
<p >Some <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> / PCC combinations should not perform PCC while rendering, either because the RenderTarget is the same as the cubemap texture, or because other glitches may occur </p>

</div>
</div>
<a id="a57e0523432c6e5133ff4fc251111a60e" name="a57e0523432c6e5133ff4fc251111a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e0523432c6e5133ff4fc251111a60e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::IdObject::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ae22596b5bd2a3faf2958ab3d109d1f" name="a0ae22596b5bd2a3faf2958ab3d109d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae22596b5bd2a3faf2958ab3d109d1f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::IdObject::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9eba922fa823c5142a3078de97cf4cc0" name="a9eba922fa823c5142a3078de97cf4cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eba922fa823c5142a3078de97cf4cc0">&#9670;&nbsp;</a></span>passEarlyPreExecute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorWorkspaceListener::passEarlyPreExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called early on in pass' execution. </p>
<p >Happens before passPreExecute, before the pass has set anything. Warning: calling pass-&gt;execute can result in recursive calls. </p>

</div>
</div>
<a id="aafb1faa16a3a3f920edf5d356160ed3e" name="aafb1faa16a3a3f920edf5d356160ed3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb1faa16a3a3f920edf5d356160ed3e">&#9670;&nbsp;</a></span>passPosExecute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorWorkspaceListener::passPosExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a pass has been executed. </p>
<p >Warning: calling pass-&gt;execute can result in recursive calls. </p>

</div>
</div>
<a id="a8f41e739f1d88f880e7ff6fbce03073a" name="a8f41e739f1d88f880e7ff6fbce03073a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f41e739f1d88f880e7ff6fbce03073a">&#9670;&nbsp;</a></span>passPreExecute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::passPreExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when each pass is about to be executed. </p>
<p >Warning: calling pass-&gt;execute can result in recursive calls. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_workspace_listener.html#a30e82f9915494734c77e2be6386045bd">Ogre::CompositorWorkspaceListener</a>.</p>

</div>
</div>
<a id="aa48c3669cc7eea1407af04641a48b955" name="aa48c3669cc7eea1407af04641a48b955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48c3669cc7eea1407af04641a48b955">&#9670;&nbsp;</a></span>passSceneAfterFrustumCulling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorWorkspaceListener::passSceneAfterFrustumCulling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass_scene.html">CompositorPassScene</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a pass scene has performed frustum caulling but has yet to prepare and execute rendering commands. </p>
<p >Gets called after passSceneAfterFrustumCulling and before passPosExecute</p>
<p >Warning: calling pass-&gt;execute can result in recursive calls. </p>

</div>
</div>
<a id="a75c7e6c919c3bf55475a0a04160189fc" name="a75c7e6c919c3bf55475a0a04160189fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c7e6c919c3bf55475a0a04160189fc">&#9670;&nbsp;</a></span>passSceneAfterShadowMaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorWorkspaceListener::passSceneAfterShadowMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass_scene.html">CompositorPassScene</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a pass scene has rendered shadow casting (it gets called even if there is no shadow node). </p>
<p >Gets called after passPreExecute and before passSceneAfterFrustumCulling</p>
<p >Warning: calling pass-&gt;execute can result in recursive calls. </p>

</div>
</div>
<a id="ac13b25da99dc231bd118cc45353d7a6c" name="ac13b25da99dc231bd118cc45353d7a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13b25da99dc231bd118cc45353d7a6c">&#9670;&nbsp;</a></span>prepareForClearScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::prepareForClearScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the Proxy Items. </p>
<p >Useful if you need to call sceneManager-&gt;clearScene(); The you MUST call this function before. i.e. pcc-&gt;<a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ac13b25da99dc231bd118cc45353d7a6c" title="Destroys the Proxy Items.">prepareForClearScene()</a>; sceneManager-&gt;clearScene(); pcc-&gt;<a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#adee0f24e40d71aedd68a96f63c5edb17">restoreFromClearScene()</a>; Updating <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html">ParallaxCorrectedCubemap</a> without calling prepareForClearScene/restoreFromClearScene will result in a crash. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#aa48567e7d67be5cf41ff808b1f3ae38c">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="aed2c8908f3b3eacd7e688392ff1c691c" name="aed2c8908f3b3eacd7e688392ff1c691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2c8908f3b3eacd7e688392ff1c691c">&#9670;&nbsp;</a></span>releaseIbl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::releaseIbl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>tmpRtt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a039657d1c26eee4e9a7c412d5be12ed9">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="a932214b69592fe3313cb4d179d01de3a" name="a932214b69592fe3313cb4d179d01de3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932214b69592fe3313cb4d179d01de3a">&#9670;&nbsp;</a></span>releaseTmpRtt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::releaseTmpRtt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>tmpRtt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#a1d2171d5ea888673260e32f13f797439">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="adee0f24e40d71aedd68a96f63c5edb17" name="adee0f24e40d71aedd68a96f63c5edb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee0f24e40d71aedd68a96f63c5edb17">&#9670;&nbsp;</a></span>restoreFromClearScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ParallaxCorrectedCubemapBase::restoreFromClearScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap.html#acd4aab1e04f22bbc8b27b7d643bc76a0">Ogre::ParallaxCorrectedCubemap</a>.</p>

</div>
</div>
<a id="a0e40f6c89fcfdfee2057ca6efe622299" name="a0e40f6c89fcfdfee2057ca6efe622299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e40f6c89fcfdfee2057ca6efe622299">&#9670;&nbsp;</a></span>setEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::setEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>maxNumProbes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables this <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html" title="Per-Pixel reflection probes.">ParallaxCorrectedCubemapAuto</a> system. </p>
<p >It will (de)allocate some resources, thus it may cause stalls. If you need to temporarily pause the system (or toggle at high frequency) use mPaused instead (it's a public variable). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnabled</td><td>True to enable. False to disable. When false, the rest of the arguments are ignored. </td></tr>
    <tr><td class="paramname">width</td><td>Unlike the manual system, in PCC Auto all probes must use the same resolution </td></tr>
    <tr><td class="paramname">height</td><td>Unlike the manual system, in PCC Auto all probes must use the same resolution </td></tr>
    <tr><td class="paramname">maxNumProbes</td><td>Max number of probes. Necessary. On AMD GCN cards, this should be a power of 2 otherwise the driver will internally round it up (and waste memory) </td></tr>
    <tr><td class="paramname">pixelFormat</td><td>PixelFormatGpu for the cubemap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa948bcd4631267cd46bc10e0a85bd225" name="aa948bcd4631267cd46bc10e0a85bd225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa948bcd4631267cd46bc10e0a85bd225">&#9670;&nbsp;</a></span>setListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto_listener.html">ParallaxCorrectedCubemapAutoListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66abd5518918092b8d4ee072dfa172bf" name="a66abd5518918092b8d4ee072dfa172bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66abd5518918092b8d4ee072dfa172bf">&#9670;&nbsp;</a></span>setUpdatedTrackedDataFromCamera()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::setUpdatedTrackedDataFromCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>trackedCamera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will update both mTrackedPosition with appropiate settings every time it's called. </p>
<p >Must be called every time the camera changes.</p>
<p >This information is used to know which nearby non-static probes need to be updated every frame. </p><dl class="section remark"><dt>Remarks</dt><dd>You don't <em>have to</em> use a camera, which is why mTrackedPosition is a public variables. Sometimes you want something else to be used as reference for probe update (e.g. character's position instead of the camera). This is up to you. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackedCamera</td><td><a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> whose settings to use as reference. We will not keep a reference to this pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42e542a62cb671f6f0a394bcb1130c71" name="a42e542a62cb671f6f0a394bcb1130c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e542a62cb671f6f0a394bcb1130c71">&#9670;&nbsp;</a></span>setUseDpm2DArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::setUseDpm2DArray </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useDpm2DArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether we should use Dual Paraboloid Mapping with 2D Array instead of Cubemap Arrays. </p>
<dl class="section remark"><dt>Remarks</dt><dd>DPM is lower quality than cubemap arrays. However not all GPUs support cubemap arrays, most notably iOS GPUs before A11 chips and DX10 level HW.</dd></dl>
<p>When cubemap arrays are not supported, this setting is always forced on.<br  />
 When cubemap arrays are supported, it's up to you. The most likely reason you want to use DPM overy cubemap arrays is to see how it looks like on unsupported platforms.</p>
<p >You cannot toggle this setting after enabling the system. You must call ParallaxCorrectedCubemapAuto::setEnabled( false, ... ); to switch this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useDpm2DArray</td><td>True to use DPM, cubemap arrays otherwise. Default: False unless GPU does not support cubemap arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdabb26cc06821e04f6ce6e3853755d0" name="afdabb26cc06821e04f6ce6e3853755d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdabb26cc06821e04f6ce6e3853755d0">&#9670;&nbsp;</a></span>updateAllDirtyProbes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ParallaxCorrectedCubemapAuto::updateAllDirtyProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>By default the probes will be constructed when the user enters the vecinity of non-static probes, and whenever a static probe is dirty. </p>
<p >This can cause noticeable stalls. Use this function to regenerate them all at once (i.e. at loading time) This function also uses a memory-friendly way of updating the probes. </p>

<p>Implements <a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_base.html#ae0e1182108b3f40d2e19b3b37f851d8a">Ogre::ParallaxCorrectedCubemapBase</a>.</p>

</div>
</div>
<a id="a71ee72b0064a1c20c05b37995e5e139e" name="a71ee72b0064a1c20c05b37995e5e139e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ee72b0064a1c20c05b37995e5e139e">&#9670;&nbsp;</a></span>workspacePosUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorWorkspaceListener::workspacePosUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td>
          <td class="paramname"><em>workspace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after all nodes has been updated. </p>

</div>
</div>
<a id="aad6aea0f666028295c3efa9dc41eaceb" name="aad6aea0f666028295c3efa9dc41eaceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6aea0f666028295c3efa9dc41eaceb">&#9670;&nbsp;</a></span>workspacePreUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorWorkspaceListener::workspacePreUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td>
          <td class="paramname"><em>workspace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before all nodes are going to be updated. </p>
<p >Use this place to update your own, manually updated Workspaces without having to call @CompositorWorkspace::_beginUpdate( forceBeginFrame=true ) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a12c0ea75c3a53a92c55be4075e3f9184" name="a12c0ea75c3a53a92c55be4075e3f9184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c0ea75c3a53a92c55be4075e3f9184">&#9670;&nbsp;</a></span>mMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::ParallaxCorrectedCubemapBase::mMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b689fd9da3fdde16a34d403dc448576" name="a3b689fd9da3fdde16a34d403dc448576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b689fd9da3fdde16a34d403dc448576">&#9670;&nbsp;</a></span>mPaused</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ParallaxCorrectedCubemapBase::mPaused</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca0f0ec0f33e0bda5ddf4b16e5265ebf" name="aca0f0ec0f33e0bda5ddf4b16e5265ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0f0ec0f33e0bda5ddf4b16e5265ebf">&#9670;&nbsp;</a></span>mTrackedPosition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> Ogre::ParallaxCorrectedCubemapAuto::mTrackedPosition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable should be updated every frame and often represents the camera position, but it can also be used set to other things like the player's character position. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_parallax_corrected_cubemap_auto_8h.html">OgreParallaxCorrectedCubemapAuto.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_parallax_corrected_cubemap_auto.html">ParallaxCorrectedCubemapAuto</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
